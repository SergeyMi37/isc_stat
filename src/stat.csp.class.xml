<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="stat.csp">
<Description><![CDATA[
csp server stat<br/>
used shm user metrics<br/>
for config is used ^|"%SYS"|SYS("stat","csp")?!
to do: avoid stat.lib usage]]></Description>
<IncludeCode>statcsp</IncludeCode>
<Super>%CSP.SessionEvents</Super>
<TimeCreated>65700,55452.852593</TimeCreated>

<Property name="log">
<Type>%String</Type>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Property name="logdir">
<Type>%String</Type>
<Parameter name="MAXLEN" value="512"/>
</Property>

<Property name="inith">
<Type>%String</Type>
</Property>

<Property name="logtimeout">
<Description>
used to query log in order write in log file under lock, avoid intermix messages from different processes</Description>
<Type>%String</Type>
</Property>

<Property name="id">
<Type>%String</Type>
</Property>

<Property name="gwReqId">
<Type>%String</Type>
</Property>

<Property name="zh">
<Type>%String</Type>
</Property>

<Property name="GloRef">
<Type>%Integer</Type>
</Property>

<Property name="Tokens">
<Type>%Integer</Type>
</Property>

<Property name="GloUpd">
<Type>%Integer</Type>
</Property>

<Property name="PhyRd">
<Type>%Integer</Type>
</Property>

<Property name="IsPhyRd">
<Type>%Boolean</Type>
</Property>

<Property name="cspapp">
<Type>%String</Type>
</Property>

<Property name="tsStart">
<Type>%String</Type>
</Property>

<Property name="url">
<Type>%String</Type>
</Property>

<Property name="docpu">
<Description>
do process cpu stat</Description>
<Type>%String</Type>
</Property>

<Property name="cpudev">
<Type>%String</Type>
</Property>

<Property name="cpudevoto">
<Description>
timeout to open cpudev</Description>
<Type>%Numeric</Type>
</Property>

<Property name="dcpu">
<Type>%String</Type>
</Property>

<Property name="GuessSelf">
<Description>
it is expected that self at constant oref for all processes</Description>
<Type>%String</Type>
</Property>

<Property name="EventClass">
<Description>
original EventClass for csp application</Description>
<Type>%String</Type>
</Property>

<Property name="EventClasses">
<Description>
saved original EventClass for csp applications</Description>
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="BrokerClass">
<Type>%String</Type>
</Property>

<Property name="BrokerMethod">
<Type>%String</Type>
</Property>

<Property name="BrokerNArgs">
<Type>%Integer</Type>
</Property>

<Property name="BrokerArgs">
<Description><![CDATA[
every broker args $$Format^%qcr(value,flag), cutof if length too bigs?<br/>]]></Description>
<Type>%String</Type>
</Property>

<Property name="CSPCHD">
<Description>
value of CSPCHD from %SYS.cspServer* got by hack trick</Description>
<Type>%String</Type>
</Property>

<Property name="dbdir">
<Description>
dbdir to put data</Description>
<Type>%String</Type>
</Property>

<Property name="fsdlm">
<Description>
file system delimiter</Description>
</Property>

<Property name="platform">
<Description>
plaform name winnt,linux, ...</Description>
<Type>%String</Type>
</Property>

<Property name="cspSessionStat">
<Description><![CDATA[
collect csp sessions statistics @CtlGlo@("csp","session")<br/>
^|CACHE|stat.csp(sessionid)
it is not clear motivation to have this]]></Description>
<Type>%Boolean</Type>
</Property>

<Method name="OnStartRequest">
<Description><![CDATA[
sessionid is argument it is proposal, it is expected from http header cookie, it might be changed on csp server processing<br/>
causious %session is underfined<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>sessionid:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 set $ztrap="error"
 try { set usm=-10 set usm=..usm() } catch {}
 if $G(%request)'="" && ($isobject(%request)) { set url=%request.URL}
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnStartRequest usm="_usm_",%request="_$G(%request)_",%session="_$G(%session)_",sessionid="_$G(sessionid)_",url="_$G(url) ))
 if usm < 1 quit $$$OK
 try {
   set retec=$$$OK
#;   set staton=$zu(133,6,usm,1)
#;   set staton=$$$usmGetCSPFileLog(usm)
   set staton=$$$usmGet(usm,$$$usmCSPStat)
   set stat=""
   if staton {
     set stat=..self()
     $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnStartRequest self="_$G(stat)))
     if stat'="" {
#; dirty hack to get CSPCHD from %SYS.cspServer*
       try {
         set n=$zu(41)-1 for i=n:-1:1 { 
         try { set CSPCHD=$zu(43,i,"CSPCHD") } catch {}
         quit:$D(CSPCHD)
         try { set CSPCHD=$zu(43,i,"~CSPCHD") } catch {}
         quit:$D(CSPCHD) }
       } catch { do $zu(9,"",..%ClassName(1)_" OnStartRequest $ZE="_$ZE) }
#; end of dirty hack
       if $D(CSPCHD) set stat.CSPCHD=CSPCHD
       $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnStartRequest sessionid="_$E($G(CSPCHD),13,22)_",CSPCHD="_$G(CSPCHD)))
       set h=$h if $P(stat.inith,",",1)'=$P(h,",",1) do stat.switchlog(h)
       set log=stat.log
       set logtimeout=stat.logtimeout
       set id=$$$usmInc(usm,$$$usmReqId) // increment csp server stat http request id
       set stat.id=id
       set stat.gwReqId=%request.RequestId
       set cspapp=%request.Application
       if cspapp'="" {
          set cspapp2=cspapp if $E(cspapp,$L(cspapp))="/" set cspapp2=$E(cspapp,1,$L(cspapp)-1)
          set EventClass=$G(stat.EventClasses(cspapp2))
       } else { set EventClass="" }
       set stat.cspapp=cspapp
       set stat.EventClass=EventClass
       set stat.BrokerClass=""
       $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnStartRequest reqid="_id_" cspapp="_cspapp_" EventClass="_EventClass))
       set jid=$$$JID
       if $isobject($G(%session)) { set sessionid=%session.SessionId set application=%session.Application }
       else { set application="" }
       if $G(sessionid)="" set sessionid=$E(stat.CSPCHD,13,22)
       set tsStart=$zdt($h,3)_"."_$P($zts,".",2),stat.tsStart=tsStart
       if $zboolean(staton,$$$CSPLogFile,1) {
         set io=$io set zh=$zh lock +^%stat.csp.logfile:logtimeout if $test {
           open log:("WSA"):logtimeout if $test {
             set zh2=$zh use log
             try {
               W tsStart_","_id_",s,"_$G(sessionid)_","_%request.RequestId_","_jid_","_$J_","_%request.URL_","_$znspace_","_%request.Class_","_cspapp_","_
                 %request.Method_","_%request.GetCgiEnv("REMOTE_ADDR")_","_%request.GetCgiEnv("REMOTE_PORT")_","_
                 %request.GetCgiEnv("SERVER_ADDR")_","_%request.GetCgiEnv("SERVER_PORT")_"," _application_$C(10)
               #;if %request.Class="%CSP.StreamServer" { W ","_id_",ss"_","_$G(%request.Data("FILE",1))_$C(10) }
               close log lock -^%stat.csp.logfile use io
               set dt=$zh-zh2
             $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnStartRequest write in CSP log file dt="_dt))
             }
             catch { use io close log do $zu(9,"",..%ClassName(1)_" OnStartRequest %request="_$G(%request)_"$ZE="_$ZE) }
           }
         }
         else {
           do $zu(9,"",..%ClassName(1)_" OnStartRequest unable get lock during "_logtimeout_" for writing in CSP log file")
         }
       }
       if $zboolean(staton,$$$CSPLogGlobal,1) {// prepare data for csp logging in global at runtime
       }
       set stat.zh=$zh set stat.Tokens=$zu(61,8,jid) set stat.GloRef=$zu(61,9,jid)
       if stat.IsPhyRd { set stat.GloUpd=$zu(61,35,jid) set stat.PhyRd=$zu(61,34,jid) }
       if stat.docpu=1 {
         set io=$io set t="" try {
           open stat.cpudev:stat.cpudevoto if $test {
              use stat.cpudev read t use io set stat.dcpu=t
              #;use stat.cpudev:0 read t use io set stat.dcpu=t
           }
         }
         catch {
           use io set stat.dcpu=""
           do $zu(9,"",$ZNAME_" OnStartRequest dev="_(stat.cpudev)_",$ZE="_$ZE)
         }
       }
     } else { do $zu(9,"",..%ClassName(1)_" csp stat process singleton not found") }
   }
 } catch e { do $zu(9,"",..%ClassName(1)_" OnStartRequest $ZE="_$ZE) }
 try { if stat.EventClass'="" { set retec=$classmethod(stat.EventClass,"OnStartRequest") } } catch e {}
 Quit retec
error
 do $ZU(9,"","stat.csp $ZE="_$ZE)
 quit retec
]]></Implementation>
</Method>

<Method name="OnEndRequest">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 set $ztrap="error"
 set retec=$$$OK
 try { set usm=-10 set usm=..usm() } catch {}
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnEndRequest usm="_usm_",tryself="_$case(usm'<1,1:$$$usmGet(usm,$$$usmTrySelf),:"")_",%session="_$G(%session)_",sessionid="_$case($isobject($G(%session)),1:%session.SessionId,:"")_",%request="_$G(%request)))
 if usm<1 quit $$$OK
 try {
   set staton=$$$usmGet(usm,$$$usmCSPStat)
   if staton {
      set stat=..self()
      if stat'="" && $isobject(stat) && ($classname(stat)=..%ClassName(1) ) {
        if stat.docpu {
          set io=$io set t2="" try {
            #;open stat.cpudev:0.1
            use stat.cpudev:0 read t2 use io close stat.cpudev
            #;use stat.cpudev read t2 use io
            set t1=stat.dcpu
            if t2'=""&&(t1'="") {
              set stat.dcpu=$LB($$$NanoToMicroSecPrecision($P(t2," ",1)-$P(t1," ",1)),$$$NanoToMicroSecPrecision($P(t2," ",2)-$P(t1," ",2)),$P(t2," ",3)-$P(t1," ",3))
            }
            else { set stat.dcpu=$LB("","","") }
          }
          catch {
            use io
            do $zu(9,"",$ZNAME_" OnEndRequest dev="_stat.cpudev_",$ZE="_$ZE)
          }
        }
        set h=$h if $P(stat.inith,",",1)'=$P(h,",",1) do stat.switchlog(h)
        set log=stat.log
        set logtimeout=stat.logtimeout
        set jid=$$$JID
        if $isobject($G(%session)) && ($classname(%session)="%CSP.Session") {
          set sessionid=%session.SessionId
          set licenseid=%session.LicenseId
          set sessionNew=%session.NewSession
          set sessionEnd=%session.EndSession
        }
        set tsEnd=$zdt($h,3)_"."_$P($zts,".",2)
        set duration=$zh-stat.zh
        set tokens=$zu(61,8,jid)-stat.Tokens
        set gloref=$zu(61,9,$zu(61))-stat.GloRef
        if stat.IsPhyRd { set gloupd=$zu(61,35,$zu(61))-stat.GloUpd set PhyRd=$zu(61,34,$zu(61))-stat.PhyRd }
        else { set gloupd="",PhyRd="" }
        set dcpu=stat.dcpu
        if $zboolean(staton,$$$CSPLogFile,1) {
          set io=$io lock +^%stat.csp.logfile:logtimeout if $test {
            open log:("WSA"):logtimeout if $test {
              use log
              try {
                if stat.BrokerClass'="" W ","_stat.id_",ba,"_$SYSTEM.Encryption.Base64Encode(stat.BrokerArgs,1)_$C(10)
                W tsEnd_","_stat.id_",e,"_$G(sessionid)_","_$G(licenseid)_","_$G(sessionNew)_","_$G(sessionEnd)_","_
                 duration_","_tokens_","_gloref_","_gloupd_","_PhyRd_","_$LG(dcpu,1)_","_$LG(dcpu,2)_","_$LG(dcpu,3)_","_stat.BrokerClass_","_stat.BrokerMethod_","_stat.BrokerNArgs_$C(10)
                 use io close log lock -^%stat.csp.logfile
              }
              catch e {
                use io close log lock -^%stat.csp.logfile
                do $zu(9,"",..%ClassName(1)_" OnEndRequest $ZE="_$ZE)
              }
            } /* else { try { use io close log } catch {} } */
          }
          else { do $zu(9,"",..%ClassName(1)_" OnEndRequest unable get lock during "_logtimeout_" for writing in csp stat log file") }
        }
        if $zboolean(staton,$$$CSPLogGlobal,1) {
           $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnEndRequest class="_stat.BrokerClass_" method="_stat.BrokerMethod))
           set ^|stat.dbdir|stat.csp(stat.id)=$LB(,jid,$J,$G(sessionid),$G(sessionNew),$G(sessionEnd),$E(stat.CSPCHD,13,22),licenseid,stat.gwReqId,duration,
             stat.tsStart/*11*/,tsEnd/*12*/,%request.URL/*13*/,%request.Method/*14*/,$znspace/*15*/,%request.Class/*16*/,stat.cspapp/*17*/,
             %request.GetCgiEnv("REMOTE_ADDR")/*18*/,%request.GetCgiEnv("REMOTE_PORT")/*19*/,
             %request.GetCgiEnv("SERVER_ADDR")/*20*/,%request.GetCgiEnv("SERVER_PORT")/*21*/,
             tokens/*22*/,gloref/*23*/,gloupd/*24*/,PhyRd/*25*/,$LG(dcpu,1)/*26*/,$LG(dcpu,2)/*27*/,$LG(dcpu,3)/*28*/,stat.BrokerClass/*29*/,stat.BrokerMethod/*30*/,stat.BrokerNArgs/*31*/,stat.BrokerArgs/*32*/)
        }
      }
      else { do $zu(9,"",..%ClassName(1)_"OnEndRequest csp stat singleton not found self="_self) }
   }
   try { if stat.EventClass'="" { set retec=$classmethod(stat.EventClass,"OnEndRequest") } } catch e {}
 } catch e { do $zu(9,"",..%ClassName(1)_" $ZE="_$ZE) }
 Quit retec
error
 do $zu(9,"","stat.csp $ZE="_$ZE)
 quit retec
]]></Implementation>
</Method>

<Method name="OnStartSession">
<Description>
1 time session start
2 time session end
3 url session start
4 url session end
5 session duration ?
6 client ip
7 client port</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set $ztrap="error"
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnStartSession %session="_$G(%session)_", sessionid="_$case($isobject($G(%session)),1:%session.SessionId,:"")))
 set ret=$$$OK set stat=..self()
 try { set um=-10 set usm=..usm() } catch {}
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnStartSession self="_$G(stat)_",usm="_usm_$case(usm'<1,1:",track session="_$zboolean($$$usmGet(usm,$$$usmCSPStat),4,1),:"") ))
 if usm'<1 && $zboolean($$$usmGet(usm,$$$usmCSPStat),$$$CSPSessionTrack,1) && ($G(%session)'="") && ($isobject(%session)) {
    set sessionid=%session.SessionId if sessionid'="" {
      do $zu(9,"",..%ClassName(1)_" OnStartSession sessionid="_sessionid)
      set data=$G(^|"^^"_$zu(12)_"cachelib/"|stat.csp.session(sessionid))
      set $LI(data,$$$CspSessionStartTime)=$zdt($h,3)
      set $LI(data,$$$CspSessionEndTime)=""
      set $LI(data,$$$CspSessionEndTime)=%request.URL
      set $LI(data,$$$CspSessionEndURL)=""
      set $LI(data,$$$CspSessionDuration)=""
      set $LI(data,$$$CspSessionClientIp)=%request.GetCgiEnv("REMOTE_ADDR")
      set $LI(data,$$$CspSessionClientPort)=%request.GetCgiEnv("REMOTE_PORT")
      if sessionid'="" set ^|"^^"_$zu(12)_"cache"|stat.csp.sessions(sessionid)=data
      if $G(stat)'="" && $isobject(stat) && ..%ClassName(1)=$classname(stat) {
        if $G(%session)'="" && $isobject(%session) { set cspapp=%session.Application }
         else { set cspapp="" }
        if $E(cspapp,$L(cspapp))="/" set cspapp=$E(cspapp,1,$L(cspapp)-1)
        if cspapp'="" set self.EventClass=$G(^SYS("stat","csp","EventClass",cspapp))
      }
    }
 }
 try { if stat.EventClass'="" { set ret=$classmethod(stat.EventClass,"OnStartSession") } } catch e {}
 Quit ret
error
 do $ZU(9,"","stat.csp $ZE="_$ZE)
 quit ret
]]></Implementation>
</Method>

<Method name="OnEndSession">
<Description><![CDATA[
%request might be undefined<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set $ztrap="error"
 set ret=$$$OK set stat=..self()
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnEndSession %session="_$G(%session)_", sessionid="_$case($isobject($G(%session)),1:%session.SessionId,:"")_",%request="_$G(%request)_",self="_$G(self) ))
 try { if stat.EventClass'="" { set ret=$classmethod(stat.EventClass,"OnEndSession") } } catch e {}
 try { set usm=-10 set usm=..usm() } catch {}
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnEndSession %session="_$G(%session)_", self="_$G(stat)_",usm="_usm_$case(usm'<1,1:",track session="_ $zu(133,6,usm,7))))
 if usm'<1 && $zboolean($$$usmGet(usm,$$$usmCSPStat),$$$CSPSessionTrack,1) && ($G(%session)'="") && ($isobject(%session)) {
   set sessionid=%session.SessionId if sessionid'="" {
     set data=$G(^|"^^"_$zu(12)_"cache"|stat.csp.session(sessionid))
     set $LI(data,$$$CspSessionEndTime)=$zdt($h,3)
     set $LI(data,$$$CspSessionEndURL)=$case($isobject($G(%request)),1:%request.URL,:"")
     set ^|"^^"_$zu(12)_"cache"|stat.csp.session(sessionid)=data
   }
 }
 Quit
error
 do $ZU(9,"","stat.csp $ZE="_$ZE)
 quit ret
]]></Implementation>
</Method>

<Method name="OnLogin">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 set ret=$$$OK set self=..self()
 if $G(%session)'="" && $isobject(%session) {
  set cspapp=%session.SessionId
  set newsession=%session.NewSession
 }
 if $G(%request)'="" && $isobject(%request) {
   set url=%request.URL
 }
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnLogin %request="_$G(%request)_",%session="_$G(%session)_",self="_$G(self)_",url="_$G(url)))
 try { if self.EventClass'="" { set ret=$classmethod(self.EventClass,"OnLogin") } } catch e {}
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnLogout">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 set ret=$$$OK set stat=..self()
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnLogout %session="_$G(%session)_",self="_$G(self) ))
 try { if stat.EventClass'="" { set ret=$classmethod(stat.EventClass,"OnLogout") } } catch e {}
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnTimeout">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set ret=$$$OK set stat=..self()
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnTimeOut %session="_$G(%session)_",self="_$G(stat) ))
 try { if stat.EventClass'="" { set ret=$classmethod(stat.EventClass,"OnTimeout") } } catch e {}
 Quit
]]></Implementation>
</Method>

<Method name="OnApplicationChange">
<ClassMethod>1</ClassMethod>
<FormalSpec>oldapp:%String,newapp:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnApplicationChange oldapp="_$G(oldapp)_" newapp="_$G(newapp)))
 set ret=$$$OK set self=..self()
 $$$DEBUGCODE(do $zu(9,"",..%ClassName(1)_" OnApplicationChange %request="_$G(%request)_",%session="_$G(%session)_",self="_$G(self)))
 try { if self.EventClass'="" { set ret=$classmethod(self.EventClass,"OnApplicationChange",oldapp,newapp) } } catch e {}
 if $isobject(self) && $classname(self)_..%ClassName(1) { set self.cspapp=$G(newapp) }
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnBrokerCall">
<ClassMethod>1</ClassMethod>
<FormalSpec>BrokerClass,BrokerMethod,args</FormalSpec>
<Implementation><![CDATA[
 set $ztrap="error"
 try { set usm=-10 set usm=..usm() } catch {}
 #;do $zu(9,"",..%ClassName(1)_" OnBrokerCall 2 class="_BrokerClass_" method="_BrokerMethod_",usm="_usm)
 if usm < 1 quit
 set staton=$$$usmGet(usm,$$$usmCSPStat)
 #;do $zu(9,"",..%ClassName(1)_" OnBrokerCall 3 class="_BrokerClass_" method="_BrokerMethod_",staton="_$G(staton))
 if staton>0 {
   set self=..self()
   #;do $zu(9,"",..%ClassName(1)_" OnBrokerCall 4 self="_self)
   if self'="" && $isobject(self) && ($classname(self)=..%ClassName(1)) {
     #;do $zu(9,"",..%ClassName(1)_" OnBrokerCall 5 self="_self)
     set self.BrokerClass=BrokerClass
     set self.BrokerMethod=BrokerMethod
     if $G(args)>0 {
       set self.BrokerNArgs=args
       #;set v="" for i=1:1:args { set v=v_$case(v="",1:"",:",")_"'"_args(i)_"'" }
       set v="" for i=1:1:args { set v=v_$LB(args(i)) }
       set self.BrokerArgs=v
     }
   }
 }
 quit
error
 set $ztrap=""
 do $zu(9,"",%ClassName(1)_" OnBrokerCall_$ZE="_$ZE)
]]></Implementation>
</Method>

<Method name="new">
<Description>
create instance and initialize context</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 try {
   set self=..%New()
   set x=$zobjincref(self)
   try { set self.IsPhyRd=1 set x=$zu(61,8,$zu(61)) } catch e { set self.IsPhyRd=0 }
   set CtlGlo=$$CtlGlo^stat.lib
   set self.logdir=$$logdir^stat.lib
#; if stat logodir is not defined user mgr directory
   if self.logdir="" set self.logdir=$zu(12)
   set h=$h
#; name of log file
   set log=..log(self.logdir,"stat_csp",h)
   $$$DEBUGCODE(do $zu(9,"","stat.csp new log="_log))
   set self.inith=h
   set logtimeout=$G(@CtlGlo@("csp","logtimeout"),0.1)
   try { if $$unix^stat.lib do sumask^stat.lib("rw-rw-r--") } catch e { do $zu(9,"",$ZNAME_" $ZE="_$ZE)}
   if '##class(%File).Exists(log) {
     lock +^stat.csp.logfile
     open log:("NWS"):logtimeout
     set io=$io use log
     W ..hdr1()_$C(10)
     W ..hdr2()_$C(10)
     lock -^%stat.csp.logfile
     close log use io
   }
   set self.log=log
   set self.logtimeout=logtimeout
   if $G(%session)'="" && $isobject(%session) { set cspapp=%session.Application }
   else { set cspapp="" }
   if $isobject($G(%request)) && $classname(%request)="%CSP.Request" && ($G(cpsapp)="") { set cspapp=%request.Application }
   else { set cspapp="" }
   if $E(cspapp,$L(cspapp))="/" set cspapp=$E(cspapp,1,$L(cspapp)-1)
   $$$DEBUGCODE(do $zu(9,"","stat.csp new cspapp="_cspapp))
   merge self.EventClasses=@CtlGlo@("csp","EventClass")
   if cspapp'="" { set self.EventClass=$G(self.EventClasses(cspapp)) }
   set self.fsdlm=$E($zu(12),$L($zu(12)))
#if 1
   set self.dbdir="SYSSTAT"
#else
   set self.dbdir="^^"_$zu(12)_self.fsdlm_"cache"
#endif
   set platform=$$platform^stat.lib
   set self.docpu=0
   if platform="linux" {
     set cpudevoto=$G(^SYS("stat","csp","procputimeout"),0.1)
     set self.cpudevoto=cpudevoto
     set cpudev="/proc/"_$P($J,":",1)_"/schedstat"
     open cpudev:("RS"):cpudevoto
     if $test {
       set self.docpu=1 set self.cpudev=cpudev close cpudev
     }
     else {
       set self.docpu=0
       #;do $zu(9,$ZNAME_" new open proc cpu fail")
     }
   }
   #;do $zu(9,"",..%ClassName(1)_" new docpu="_self.docpu_",platform="_platform_",cpudev="_cpudev)
   set self.platform=platform
 }
 catch e { do $zu(9,"",..%ClassName(1)_" new() $ZE="_$ZE) }
 quit self
]]></Implementation>
</Method>

<Method name="switchlog">
<FormalSpec>h:%String</FormalSpec>
<Implementation><![CDATA[
 set log=..log(..logdir,"stat_csp",h)
 set ..log=log
 set ..inith=h
 set logtimeout=..logtimeout
 if ##class(%File).Exists(log) quit
 set io=$io lock +^%stat.csp.logfile:logtimeout if $test {
   open log:("WSN"):logtimeout use log
   W ..hdr1()_$C(10)
   W ..hdr2()_$C(10)
   close log lock -^%stat.csp.logfile use io
 }
 #; lock failes
 else {}
]]></Implementation>
</Method>

<Method name="hdr1">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ quit "time,id,stage=s,sessionid,gwReqId,jid,pid,url,ns,class,cspapp,method,cliip,cliport,websrvip,webserverport"
]]></Implementation>
</Method>

<Method name="hdr2">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ quit "time,id,stage=e,sessionid,licenseid,sessionNew,sessionEnd,dt,tokens,gloref,gloupd,phyrd"
]]></Implementation>
</Method>

<Method name="delete">
<Description>
decrement ref to stat.csp oref, if there is no var to this oref object discarded</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set oref=..findself()
  if oref'="" set x=$zobjdecref(oref)
]]></Implementation>
</Method>

<Method name="deleteall">
<Description>
like delete() but scan all objects in process</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set classname=..%ClassName(1)
 set oref="" for {
    set oref=$zobjnext(oref) quit:oref=""
    if $classname(oref)=classname { try {set x=$zobjdecref(oref) } catch {} }
 }
]]></Implementation>
</Method>

<Method name="self">
<Description>
find or create self</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 try {
   set self="" set classname=..%ClassName(1)
   set usm=..usm() if usm'<1 { set tryself=$$$usmGet(usm,$$$usmTrySelf) }
   try { set self=$zobjref(tryself) } catch { set self="" }
   if $isobject(self) && ($classname(self)=classname) goto exit
   set self=..findself(classname)
   if self'="" set x=$$$usmSet(usm,$$$usmTrySelf,+self) goto exit
   set self=..new()
 } catch e { 
#;  set self=..new() 
   do $zu(9,"",..%ClassName(1)_" self $ZE="_$ZE)
 }
exit
 quit self
]]></Implementation>
</Method>

<Method name="findself">
<Description><![CDATA[
find oref to stat.csp object, it is singleton i.e. only one copy of object.<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>classname=""</FormalSpec>
<Implementation><![CDATA[
 set self="" if classname="" { set classname=..%ClassName(1) }
 set oref="" for {
   set oref=$zobjnext(oref) quit:oref=""
   if $classname(oref)=classname set self=oref quit
 }
 quit self
]]></Implementation>
</Method>

<Method name="log">
<Description>
make log file name</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>logdir,statlogprefix,h</FormalSpec>
<Implementation><![CDATA[ quit logdir_statlogprefix_"_"_ $tr($zdt($P(h,",",1),3),"-","_")_".log"
]]></Implementation>
</Method>

<Method name="usm">
<Description>
shared memory user metric</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set tid=$zu(133,1,..%ClassName(1))
 if tid<1 {
   set tid=$zu(133,1,..%ClassName(1),$$$usmSize,"csp","csp stat")
   #; stat is off
   set x=$zu(133,6,tid,1,0)
   set x=$zu(133,6,tid,2,0)
   #; csp session statistic is off
   set x=$zu(133,6,tid,7,0)
   set x=$zu(133,6,tid,$$$usmTrySelf,1)
   quit tid
 }
 else { quit tid }
]]></Implementation>
</Method>

<Method name="getEnabled">
<Description>
get csp stat state enabled/disabled</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set um=..usm() if um<1 quit -1
  quit $$$usmGet(um,1)
]]></Implementation>
</Method>

<Method name="setEnabled">
<Description><![CDATA[
bit 0 csp log into file, bit 1 csp log into global<br/>
0 no log, 1 file only, 2 global only, 3 file and global<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>switch:%Boolean</FormalSpec>
<Implementation><![CDATA[
 set usm=..usm() if usm<1 quit -1
 set statold=$$$usmGet(usm,$$$usmCSPStat)
 set stat=statold\4*4+(switch#4)
 set x=$$$usmSet(usm,$$$usmCSPStat,stat)
 quit statold#4
]]></Implementation>
</Method>

<Method name="getStateText">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set t="csp server stat"
 set installed=$G(^SYS("stat","csp","installed"),0)
 if installed=1 {
   try { set usm=-10 set usm=..usm() } catch {}
     set t=t_" installed"
   if usm<0 { set t=t_" getting shared mem failure"}
   else {
     set staton=$$$usmGet(usm,$$$usmCSPStat)
     if $$$IsCSPLogFile(staton) || $$$IsCSPLogGlobal(staton) {
       set t=t_", active: logging in "
       if $$$IsCSPLogFile(staton) set t2="file"
       if $$$IsCSPLogGlobal(staton) set t2=$G(t2)_$case($G(t2)="",1:"",:", ")_"global"
       set t=t_t2
     }
     else { set t=t_", not active" }
   }
 }
 elseif installed=0 { set t=t_" not installed" }
 quit t
]]></Implementation>
</Method>

<Method name="startup">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set cspinstalled=$G(^SYS("stat","csp","installed"),0)
 if cspinstalled=0 quit 0
 try { set usm=-10 set usm=..usm() } catch {}
 if usm<1 { quit 0 }
 set ctlglo=$$CtlGlo^stat.lib
 set reqid=$G(@ctlglo@("csp","reqid"),0)
#; additional check of reqid based on log and db
 set x=$$$usmSet(usm,$$$usmReqId,reqid)
 set csplogfile=$G(@ctlglo@("csp","log","file"),0)
 set csplogdb=$G(@ctlglo@("csp","log","db"),0)
 set cspstat=csplogdb*2+csplogfile
 #;do $zu(9,"",..%ClassName(1)_" startup cspstat="_cspstat)
 do ##class(stat.csp).setEnabled(cspstat)
 quit 1
]]></Implementation>
</Method>

<Method name="shutdown">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 do ##class(stat.csp).setEnabled(0)
 try { set usm=-10 set usm=..usm() } catch {}
 if usm<1 { quit 0 }
 set reqid=$$$usmGet(usm,$$$usmReqId)
 set ctlglo=$$CtlGlo^stat.lib
 set @ctlglo@("csp","reqid")=reqid
 quit 1
]]></Implementation>
</Method>

<Method name="getCSPSessionStatEnabled">
<ClassMethod>1</ClassMethod>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 set usm=..usm() if usm<1 { quit -1 }
 set stat=$$$usmGet(usm,$$$usmCSPStat)
 set stat=$zboolean(+stat,$$$CSPSessionTrack,1)
 quit ''stat
]]></Implementation>
</Method>

<Method name="setCSPSessionStatEnabled">
<ClassMethod>1</ClassMethod>
<FormalSpec>switch:%Boolean</FormalSpec>
<Implementation><![CDATA[
 set usm=..usm() if usm<1 { quit -1 }
 set stat=$$$usmGet(usm,$$$usmCSPStat)
 set old=$zboolean(+stat,$$$CSPSessionTrack,1)
 if (old=0) && (switch=1) { set x=$$$usmSet(usm,$$$usmCSPStat,$zboolean(stat,$$$CSPSessionTrack,7)) }
 elseif (old=1) && (switch=0) { set x=$$$usmSet(usm,$$$usmCSPStat,$zboolean(stat,$$$CSPSessionTrack,2)) }
 quit ''old
]]></Implementation>
</Method>

<Method name="DisplayCSPSessions">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set sessionid="" set fsdlm=$E($zu(12),$zu(12)) set dbdir="^^"_$zu(12)_"cache"_fsdlm
 for {
   set sessionid=$order(^|dbdir|stat.csp.session(sessionid),1,sessiondata) quit:sessionid=""
   W "sessionid="_sessionid_",b.time="_$LG(sessiondata,1)_",b.url="_$LG(sessiondata,3)_",e.time="_$LG(sessiondata,2)_",e.url="_$LG(sessiondata,4),!
 }
]]></Implementation>
</Method>

<Method name="ClearCSPSessions">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set sessionid="" set fsdlm=$E($zu(12),$zu(12)) set dbdir="^^"_$zu(12)_"cache"_fsdlm
 kill ^|dbdir|stat.csp.session
]]></Implementation>
</Method>

<Method name="JOBZSTOP">
<Description>
method to register for JOB^%ZSTOP? what for?</Description>
<ClassMethod>1</ClassMethod>
</Method>

<Method name="SystemStartup">
<Description>
set correct setting after cache startup</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>switch=""</FormalSpec>
<Implementation><![CDATA[
 if switch="" set switch=$G(^|"%SYS"|SYS("stat","csp"),0)
 do ##class(stat.csp).setEnabled(switch)
 #;do ##class(stat.csp).setCSPSessionStatEnabled(switch)
 set usm=..usm() if usm<1 do $zu(9,"",..%ClassName(1)_" user shared memory failure")
]]></Implementation>
</Method>

<Method name="checkclassmap">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set x="" try { set x=..%ClassName(1) } catch e {}
  quit x
]]></Implementation>
</Method>

<Method name="killallcsp">
<Description><![CDATA[
kill all csp server processes<br/>
purpose debugging, clean csp processes running old code<br/>]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set maxjid=$view($zu(40,2,118),-2,4) for jid=1:1:maxjid {
   set pid=$zu(61,17,jid) if pid'=0 {
     if $zu(61,10,jid)=27 { set ret=$zu(4,pid) w "jid="_jid_",pid="_pid_",terminate="_ret,! }
   }
 }
]]></Implementation>
</Method>

<Method name="objlist">
<Description>
internal used during debugging, list of oref's in current process</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set oref="" for {
   set oref=$zobjnext(oref) quit:oref=""
   W oref,!
 }
]]></Implementation>
</Method>

<Method name="cspstatmap">
<Description>
create mapping SYSSTAT database might be CACHESYS or SYSSTAT (separate)
routines stat.lib and stat.csp to SYSSTAT database
global ^SYS("stat") SYSSTAT
to delete</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 if $D(^|"SYSSTAT"|SYS("stat")) { }
 elseif $D(^|"%SYS"|SYS("stat")) {}
]]></Implementation>
</Method>

<Method name="cspapplist">
<Description>
show csp application list name,namespace,event,class</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set nsold="" if $znspace'="%SYS" set nsold=$znspace ZN "%SYS"
 set q=##class(%ResultSet).%New("Security.Applications:Detail")
 set ret=q.Execute("*",2)
 W "Name,Namespace,EventClass",!
 while q.Next() { W q.Get("Name")_","_q.Get("NameSpace")_","_q.Get("EventClass"),! }
 kill q
 if nsold'="" ZN nsold
]]></Implementation>
</Method>

<Method name="install">
<Description>
install csp server ptool
adding global and routine map to every namespace to stat database
routine mapping stat.csp.0, stat.csp.1, stat.lib to stat database
global SYS("stat") mapping to stat database
set EventClass to stat.csp if there is event class save it for restoring</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 
 set retInstall=1
 set CtlGlo=$$CtlGlo^stat.lib
 set nsstat=$znspace
 
 set nsold=""
 if $znspace'="%SYS" { set nsold=$znspace ZN "%SYS" }
 
 #;set nscfg=##class(Config.Namespaces).%OpenId(nsstat)
 #;set dbrtn=nscfg.Routines
 do ##Class(Config.Namespaces).Get(nsstat,.nsstatprops)
 set statcodedb=$G(nsstatprops("Routines"))
 #; statcodedb="" error
 
 #; travese all cspapp configs
 set qcspapp=##class(%ResultSet).%New("Security.Applications:Detail")
 set ret=qcspapp.Execute("*",2)
 while qcspapp.Next() {
   set type=qcspapp.Get("Type") if '(type\2#2||($F(type,"CSP"))) continue
   set cspapp=qcspapp.Get("Name")
   set EventClass(cspapp)=qcspapp.Get("EventClass")
   set namespace=qcspapp.Get("NameSpace")
   set cspnamespace(namespace)=""
 }
 
 #; traverse all namespaces having cspapp
 set ns="" for {
    set ns=$order(cspnamespace(ns)) quit:ns=""
    set qrmap=##class(%ResultSet).%New("Config.MapRoutines:List")
    set ret=qrmap.Execute(ns,"stat*")
    while qrmap.Next() {
       set rtn=qrmap.Get("Routine")
       set dbname=qrmap.Get("Database")
#; no need to map routines for %SYS namespace i.e. statcodedb=CACHESYS
       set statrmap(ns,rtn)=dbname
    }
    kill qrmap
    set qgmap=##class(%ResultSet).%New("Config.MapGlobals:List")
    set ret=qgmap.Execute(ns,"SYS(""stat"")")
    while qgmap.Next() {
       set name=qgmap.Get("Name")
#; no need to map SYS("stat") for %SYS namespace i.e. statcodedb=CACHESYS
       set statgmap(ns,name)=""
    }
    set ret=qgmap.Execute(ns,"rOBJ(""stat.csp.0"")")
    while qgmap.Next() { set name=qgmap.Get("Name") set db=qgmap.Get("Database") set statgmap(ns,name)=db }
    set ret=qgmap.Execute(ns,"rOBJ(""stat.csp.1"")")
    while qgmap.Next() { set name=qgmap.Get("Name") set db=qgmap.Get("Database") set statgmap(ns,name)=db }
    set ret=qgmap.Execute(ns,"rOBJ(""stat.lib"")")
    while qgmap.Next() { set name=qgmap.Get("Name") set db=qgmap.Get("Database") set statgmap(ns,name)=db }
 }
 #;B  ;set routine mapping
 set ns="" for {
    set ns=$order(cspnamespace(ns)) quit:ns=""
    if ns="%SYS" continue
#if 0
    if '$D(statrmap(ns,"stat.csp"),dbname) {
      set prop("Database")=statcodedb set ret=##class(Config.MapRoutines).Create(ns,"stat.csp",.prop) kill prop
      do ..smsg(ret,"add namespace "_ns_" map stat.csp routine to database "_statcodedb,.retInstall)
    }
    elseif dbname'=statcodedb {
      set ret=##class(Config.MapRoutines).Get(ns,"stat.csp",.prop)
      set prop("Database")=statcodedb
      set ret=##class(Config.MapRoutines).Modify(ns,"stat.csp",.prop) kill prop
      do ..smsg(ret,"change namespace "_ns_" map stat.csp routine to database "_statcodedb,.retInstall)
    }
    if '$D(statrmap(ns,"stat.lib"),dbname) {
      set prop("Database")=statcodedb set ret=##class(Config.MapRoutines).Create(ns,"stat.lib",.prop) kill prop
      do ..smsg(ret,"add namespace "_ns_" map stat.lib routine to database "_statcodedb,.retInstall)
    } elseif dbname'=statcodedb {
      set ret=##class(Config.MapRoutines).Get(ns,"stat.lib",.prop)
      set prop("Database")=statcodedb
      set ret=##class(Config.MapRoutines).Modify(ns,"stat.lib",.prop)
      kill prop 
      do ..smsg(ret,"change namespace "_ns_" map stat.lib routine to database "_statcodedb,.retInstall)
    }
#endif
#if $$$nsCodeMapModel="Routine"
    for rtn="stat.csp.0","stat.csp.1","stat.lib" {
      if '$D(statrmap(ns,rtn),dbname) {
        set prop("Database")=statcodedb set ret=##class(Config.MapRoutines).Create(ns,rtn,.prop) kill prop
        do ..smsg(ret,"add namespace "_ns_" map "_rtn_" routine to database "_statcodedb,.retInstall)
      }
      elseif dbname'=statcodedb {
        set ret=##class(Config.MapRoutines).Get(ns,rtn,.prop)
         set prop("Database")=statcodedb set ret=##class(Config.MapRoutines).Modify(ns,"stat.csp",.prop) kill prop
         do ..smsg(ret,"change namespace "_ns_" map "_rtn_" routine to database "_statcodedb,.retInstall)
      }
    }
#endif
  }
 #; check global mapping
 #;B ; set global mapping
 set ns="" for {
   set ns=$order(cspnamespace(ns)) quit:ns=""
   if ns="%SYS" continue
   if '$D(statgmap(ns,"SYS(""stat"")")) {
      set prop("Database")=statcodedb
      set ret=##class(Config.MapGlobals).Create(ns,"SYS(""stat"")",.prop) kill prop
      do ..smsg(ret,"for namespace "_ns_" add map ^SYS(""stat"") to database "_statcodedb)
   }
   else {
      set ret=##class(Config.MapGlobals).Get(ns,"SYS(""stat"")",.prop)
      if prop("Database")'=statcodedb {
        set prop("Database")=statcodedb
        set ret=##class(Config.MapGlobals).Modify(ns,"SYS(""stat"")",.prop) kill prop
        do ..smsg(ret,"for namespace "_ns_" modify map ^SYS(""stat"") to database "_statcodedb)
      }
   }
#if $$$nsCodeMapModel="GlobalROBJ"
   for rtn="stat.csp.0","stat.csp.1","stat.lib" {
     set prop("Database")=statcodedb
     set prop("Collation")=133
     if $D(statgmap(rtn),db)=0 {
       set ret=##class(Config.MapGlobals).Create(ns,"rOBJ("""_rtn_""")",.prop) kill prop
       do ..smsg(ret,"for namespace "_ns_" add map ^rOBJ("""_rtn_""") to database "_statcodedb)
     }
     else {
        if db'=statcodedb {
          set ret=##class(Config.MapGlobals).Modify(ns,"rOBJ("""_rtn_""")",.prop) kill prop
          do ..smsg(ret,"for namespace "_ns_" modify map ^rOBJ("""_rtn_""") to database "_statcodedb)
        }
     }
   }
#endif
#if 0
   set ret=##class(Config.MapGlobals).Modify(ns,"rOBJ(""stat.csp.0"":""stat.csp.1"")")
   if ns="USER" && (+ret=0) B
#endif

 }
#if 0
 kill qns
 set qns=##class(%ResultSet).%New("Config.Namespaces:List")
 set ret=qns.Execute()
 while qns.Next() {
    set namespace=qns.Get("Namespace")
    #;set namespaces(qns.Get("Namespace"))=""
 }
#endif
 #;B  ;set stat csp EventClass
 set class=..%ClassName(1)
 set cspapp="" for {
    set cspapp=$order(EventClass(cspapp),1,EventClass) quit:cspapp=""
    set cspappcfg=##class(Security.Applications).%OpenId(cspapp,,.ret)
    if +ret=0 {
      do $SYSTEM.Status.DecomposeStatus(ret,.errlist,,"en")
      W "csp application "_cspapp_" open error",!
      W " "_$G(errlist(1)),!
      continue
    }
#; here might be problem with opening cspapp
    if cspappcfg.EventClass'=class {
       if EventClass'="" { set @CtlGlo@("csp","EventClass",cspapp)=EventClass }
       set cspappcfg.EventClass=class
       set ret=cspappcfg.%Save()
       do ..smsg(ret,"set event class to stat.csp for "_cspapp,.retInstall)
    }
    if '$D(@CtlGlo@("csp","EventClass",cspapp)) { set @CtlGlo@("csp","EventClass",cspapp)=EventClass }
 }
 
 if nsold'="" ZN nsold
 set @CtlGlo@("csp","installed")=1
]]></Implementation>
</Method>

<Method name="uninstall">
<Description>
uninstall csp server ptool
restore original db mapping
restore original csp event class</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set nsold=$znspace
 set CtlGlo=$$CtlGlo^stat.lib
 
 #; remove rtn mapping
 #; remove global mapping
 
 #; restore original EventClass
 set cspapp="" for {
   set EventClass=""
   set cspapp=$order(@CtlGlo@("csp","EventClass",cspapp),1,EventClass) quit:cspapp=""
#; since then csp application might be deleted
   set cspappcfg=##class(Security.Applications).%OpenId(cspapp,,.ret)
   if +ret=0 {
     do $SYSTEM.Status.DecomposeStatus(ret,.errlis,,"en")
     W "csp application "_cspapp_" config open failure",!
     W " "_$G(errlist(1)),!
     continue
   }
   set namespace=cspappcfg.NameSpace
   set cspnamespace(namespace)=""
   if cspappcfg.EventClass'=EventClass {
     set cspappcfg.EventClass=EventClass
     set retSave=cspappcfg.%Save()
     do ..smsg(retSave,"restore original Event Class '"_EventClass_"' for csp application "_cspapp)
     if +retSave { kill @CtlGlo@("csp","EventClass",cspapp) }
     else { D $SYSTEM.OBJ.DisplayError(retSave) }
   }
 }
 #; remove mapping for test.csp for all namespace having csp
 set ns="" for {
    set ns=$order(cspnamespace(ns)) quit:ns=""
    if ns="%SYS" continue
#if 0
    #;set ret=##class(Config.MapRoutines).Delete(ns,"stat.csp")
    #;set ret=##class(Config.MapRoutines).Delete(ns,"stat.csp*")
#endif
#if $$$nsCodeMapModel="Routine"
    set ret=##class(Config.MapRoutines).Delete(ns,"stat.csp.0")
    set ret=##class(Config.MapRoutines).Delete(ns,"stat.csp.1")
    set ret=##class(Config.MapRoutines).Delete(ns,"stat.lib")
#endif
    set ret=##class(Config.MapGlobals).Delete(ns,"SYS(""stat"")")
#if $$$nsCodeMapModel="GlobalROBJ"
    for rtn="stat.csp.0","stat.csp.1","stat.lib" {
      set ret=##class(Config.MapGlobals).Delete(ns,"rOBJ("""_rtn_""")")
      do ..smsg(ret,"for namespace "_ns_" remove rOBJ"""_rtn_""") mapping")
    }
#endif
 }
 set @CtlGlo@("csp","installed")=0
]]></Implementation>
</Method>

<Method name="CspBrokerPatchInstall">
<Description><![CDATA[
Modify %CSP.Broker class for csp server stat class, method, arguments<br/>
it only modifies source code but doesn't compile class]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set m=##class(%Dictionary.MethodDefinition).%OpenId("%CSP.Broker||XecuteStr",,.ret)
 if +ret=0 set retq=$LB(0,"%CSP.Broker has no source, reinstall/update with system source",ret) quit retq
 set $LB(patchcode1,patchcode2,comment)=..CspBrokerPatchCode()
 set c=m.Implementation
 do c.Rewind()
 set c2=$classmethod($classname(c),"%New")
 set eol=0
 for {
   set len=32000
   set t=c.ReadLine(.len,.ret,.eol)
   set codeold($I(codeold))=t
   if $E(t,$L(t))=$C(13) set $E(t,$L(t))=""
   if len=-1 quit
   set t2=$zstrip(t,"<=>"," ","")
   set t2=$zstrip(t2,"<",$C(9),"")
   if t2="For i=1:1:count {" { set match(1)=1 goto copycode }
   elseif t2="If i>1 Set code=code_"",""" { set match(2)=1 goto copycode }
   elseif t2="Set arg=""WARG_""_i" { set match(3)=1 goto copycode }
   elseif t2="If $Data(%request.Data(arg,1)) {" { set match(4)=1 goto copycode }
   elseif t2="Set code=code_""%request.Data(""""""_arg_"""""",1)""" { set match(5)=t goto copycode }
   elseif t2="Set code=newList_$select(newList="""":"""",1:"" "")_setList_code_"")""" { set match(6)=t goto copycode }
   
   if $G(match(5))'="" && (+$G(matchdone(5))=0) {
 #; if there is and commented then uncomment
     set matchdone(5)=1
     set tm=match(5) for i=1:1 { quit:'(($E(tm,i)=" ")||($E(tm,i)=$C(9))) } set leftskip=i-1
     if $F(t2,patchcode1) {
       if $E(t,leftskip+1,leftskip+2)="#;" { set uncommentpatch(5)=1 do c2.WriteLine($E(tm,1,leftskip)_patchcode1_comment) }
       else { set ispatch(1)=1 }
     }
     else { do c2.WriteLine($E(tm,1,leftskip)_patchcode1_comment) set addpatch(1)=1 }
     if (($G(ispatch(5))=1)||($G(uncommentpatch(5)))=1) { continue } goto copycode
   }
   if $G(match(6))'="" && (+$G(matchdone(6))=0) { set matchdone(6)=1 do match6 if (($G(ispatch(6))=1)||($G(uncommentpatch(6)))=1) { continue } goto copycode }
copycode
   do c2.WriteLine(t)
 }
 if $G(match(6))'="" && (+$G(matchdone(6))=0) { set matchdone(6)=1 do match6 }
 #;B  /* code transformation*/
 if $G(ispatch(1),0) && $G(ispatch(2),0) { set retq=$LB(1,"patch already installed") quit retq }
 if '($G(matchdone(5),0) && $G(matchdone(6),0)) { set retq=$LB(0,"patch failed to apply") quit retq }
 set m.Implementation=c2
 #;B  /*before save*/
 set ret=m.%Save()
 if +ret=1 { set retq=$LB(1,"update") } else { set retq=$LB(0,"update",ret) }
 #;B  ;exit
 quit retq
match6
 set tm=match(6) for i=1:1 { quit:'(($E(tm,i)=" ")||($E(tm,i)=$C(9))) } set leftskip=i-1
 if $F(t2,patchcode2) {
   if $E(t,leftskip+1,leftskip+2)="#;" { set uncommentpatch(6)=1 do c2.WriteLine($E(tm,1,leftskip)_patchcode2_comment) }
   else { set ispatch(2)=1 }
 }
 else { do c2.WriteLine($E(tm,1,leftskip)_patchcode2_comment) set addpatch(2)=1 }
 set matchdone(6)=1
 quit
]]></Implementation>
</Method>

<Method name="CspBrokerPatchUninstall">
<Description><![CDATA[
remove patch code modification done by CspBrokerPatchInstall<br/>
optRemove - 0 comment out patch code<br/>
1 remove patch code]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>optRemove=0</FormalSpec>
<Implementation><![CDATA[
 set m=##class(%Dictionary.MethodDefinition).%OpenId("%CSP.Broker||XecuteStr",,.ret)
 if +ret=0 set retq=$LB(0,"%CSP.Broker has no source, reinstall/update with system source",ret) quit retq
#; to do replace t
#if 1
 set $LB(patchcode1,patchcode2,statcspPatchComment)=..CspBrokerPatchCode()
#else
 set patchcode1="set brkargs($I(brkargs))=$G(%request.Data(arg,1))"
 set patchcode2="try { do ##class(stat.csp).OnBrokerCall(cls,method,.brkargs) } catch{} kill brkargs"
 set statcspPatchComment=" // stat.csp patch"
#endif
 set c=m.Implementation
 do c.Rewind()
 set c2=$classmethod($classname(c),"%New")
 for {
   set len=32000
   set t=c.ReadLine(.len,.ret,.eol)
   if len=-1 quit
   set codeold($I(codeold))=t
   set t2=$zstrip(t,"<=>"," ","")
   set t2=$zstrip(t2,"<",$C(9),"")
   if t2="For i=1:1:count {" { set match(1)=1 goto copycode }
   elseif t2="If i>1 Set code=code_"",""" { set match(2)=1 goto copycode }
   elseif t2="Set arg=""WARG_""_i" { set match(3)=1 goto copycode }
   elseif t2="If $Data(%request.Data(arg,1)) {" { set match(4)=1 goto copycode }
   elseif t2="Set code=code_""%request.Data(""""""_arg_"""""",1)""" { set match(5)=t goto copycode }
   elseif t2="Set code=newList_$select(newList="""":"""",1:"" "")_setList_code_"")""" { set match(6)=1 goto copycode }
   
   if $G(match(5))'="" && (+$G(matchdone(5))=0) {
     set matchdone(5)=1
     for i=1:1 { quit:'(($E(t,i)=" ")||($E(t,i)=$C(9))) } set leftskip=i-1
     if $F(t,patchcode1) {
       if optRemove=0 {
         if $E(t,leftskip+1,leftskip+2)="#;" { set alreadycommentpatch(1)=1 goto copycode }
         else { do c2.WriteLine($E(t,1,leftskip)_"#;"_patchcode1_statcspPatchComment) set rmbycommentpatch(1)=1
         }
       } else { set rmpatch(1)=1 }
       continue
     }
     goto copycode
   }
   if $G(match(6))'="" && (+$G(matchdone(6))=0) {
     set matchdone(6)=1
     for i=1:1 { quit:'(($E(t,i)=" ")||($E(t,i)=$C(9))) } set leftskip=i-1
     if $F(t,patchcode2) {
       if optRemove=0 {
         if $E(t,leftskip+1,leftskip+2)="#;" { set alreadycommentpatch(2)=1 goto copycode}
         else { do c2.WriteLine($E(t,1,leftskip)_"#;"_patchcode2_statcspPatchComment) set rmbycommentpatch(2)=2 }
       } else { set rmpatch(2)=1 }
       continue
     }
     goto copycode
   }
copycode
  do c2.WriteLine(t)
 }
#; pacth remove by comment out line by #:
 if $G(alreadycommentpatch(1),0) && $G(alreadycommentpatch(2),0) { set retq=$LB(1,"patch already removed by comment out #;") quit retq }
 set m.Implementation=c2
#;B  ; uninstall before save
 set ret=m.%Save()
 if +ret=1 { set retq=$LB(1,"update") } else { set retq=$LB(0,"update",ret) }
#; B  ;exit
 quit retq
]]></Implementation>
</Method>

<Method name="CspBrokerPatchCode">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
 set prod=$P($SYSTEM.Version.GetProduct()," ")
 if prod="IRIS" { set isiris=1 } else { set isiris=0 }
 quit $LB(
   "set brkargs($I(brkargs))=$G(%request.Data(arg,1))",
   "try { do ##class(stat.csp).OnBrokerCall("_$case(isiris,1:"%class",0:"cls")_","_$case(isiris,1:"%",0:"")_"method,.brkargs) } catch{} kill brkargs",
    " // stat.csp patch"
 )
]]></Implementation>
</Method>

<Method name="smsg">
<Description>
status message</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ret,msg,retAll</FormalSpec>
<Implementation><![CDATA[
 if +ret=1 { W "ok "_msg,! quit }
 else { W "err "_msg,! set retAll=0 quit }
]]></Implementation>
</Method>
</Class>
</Export>
